# ANDES card file, 1.0

# field = elements
# an element can be a dictionary denoted with colon
# multiple elements: separate with semi-colon
# multiple lines supported

name = WTG3

doc_string = Wind turbine type III

group = WTG

data =
 gen: 0;
 wind: 0;
 Kp: 1; nblade: 3;
 ngen: 1; npole: 4;
 R: 1; Tp: 0.3;
 ngb: 1; rho: 1;
 Ks: 1; alf_s: 0;
 H: 2;
 rr: 0; rs: 0;
 xr: 1; xs: 1;
 xmu: 1; Te: 0.01;
 KV: 1;
 pmax: 1; pmin: 0;
 qmax: 1; qmin: 0;
 gammap: 1; gammaq: 1;
 u: 1; Sn: 100;

descr =
 gen: Static generator idx;
 wind: Wind time series idx;
 Kp: Pitch control gain;
 nblade: Number of blades;
 ngen: Number of generators;
 npole: Number of poles;
 R: Rotor radius;
 Tp: Pitch control time constant;
 ngb: Gear box ratio;
 rho: Air density;
 Ks: Shaft stiffness;
 alf_s: Shadow effect factor;
 H: Machine rotor and turbine inertia constant;
 rr: Rotor resistance;
 rs: Stator resistance;
 xr: Rotor reactance;
 xs: Stator reactance;
 xmu: Magnetizing reactance;
 Te: Power control time constant;
 KV: Voltage control gain;
 pmax: Maximum active power;
 pmin: Minimum reactive power;
 qmax: Maximum active power;
 qmin: Minimum reactive power;
 gammap: Active power generation ratio;
 gammaq: Reactive power generation ratio;

units =
 Kp: pu;
 R: m; Tp: s;
 rho: kg/m^3;
 Ks: pu;
 H: MWs/MVA;
 rr: pu; rs: pu;
 xr: pu; xs: pu;
 xmu: pu; Te: s;
 KV: pu;
 pmax: pu; pmin: pu;
 qmax: pu; qmin: pu

params = Kp; nblade; ngen; npole; R; Tp; ngb; rho; Ks; alf_s; H; rr; rs; xr; xs; xmu; Te; KV; pmax; pmin; qmax; qmin; gammap; gammaq

mandatory = gen; wind

times = Tp; Te

# zeros = T6

ctrl =
 bus: StaticGen, bus, gen, c;
 v: Bus, v, bus, y;
 a: Bus, a, bus, y;
 p0: Bus, Pg, bus, c;
 q0: Bus, Qg, bus, c;
 vw: Wind, vw, wind, y;

algebs = isd; isq; vrd; vrq; vsd; vsq; vref; pwa; pw; cp; lamb; ilamb; omega_ref
fnamey = I_{s, d}; I_{s, q}; V_{r, d}; V_{r, q}; V_{s, d}; V_{s, q}; V_{ref}; P_{\omega a}; P_w; c_p; \lambda; \frac{1}{\lambda}; \omega_{ref}

states = theta_p; omega_m; ird; irq;
fnamex = \theta_p; \omega_m; I_{r, d}; I_{r, q};

interfaces = a; v

service_eq =
 vref0: v;
 x0: xs + xmu;
 pi: 3.14;
 phi: 0.1;

init1_eq =


algeb_eq =
 -rs * isd + (x0*isq + xmu*irq) - vsd;
 -rs * isq - (x0*isd + xmu*ird) - vsq;
 -rr*ird + (1 - omega_m)*(x0*irq + xmu*isq);
 -rr*irq - (1 - omega_m)*(x0*ird + xmu*isd);
 -v*sin(a);
 v*cos(a);
 vref0 - vref;
 2*omega_m - 1 - pwa;
 (ngen * rho / 2 / Sn) * (pi * R **2) * vw ** 3 * cp - pw;
 0.22 * (116* ilamb - 0.4 * theta_p - 5 ) * exp(-12.5 * ilamb) - cp;
 omega_m * R / vw - lamb;
 1 / (lamb + 0.08 * theta_p) - 0.035 / (theta_p ** 3 + 1) - ilamb;
 1 - omega_ref;
 u * (-vsd * isd - vsq * isq - vrd * ird - vrq * irq);
 u * (v**2/xmu + v*xmu*ird/x0);

hard_limit =
 pwa: 0, 1;

diff_eq =
 (Kp * phi *(omega_m - omega_ref) - theta_p) / Tp;
 ((pw/omega_m) - xmu * (irq * isd - ird * isq)) / (2 * H);
 (- x0 / xmu / v * pwa / omega_m - irq) / Te;
 KV * (v - vref) - v / xmu - ird;

# 1. Delete self.pi in self.servcall(self, dae); replace all self.pi with pi;
# 2.